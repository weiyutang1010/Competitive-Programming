/*
 * generated by github.com/calgagi/cp_gen
 * author: weiyutang
 * file: AdventOfCode.cpp
 */

#include <bits/stdc++.h>
using namespace std;

/* ===== BEGIN USER CODE ===== */

#define ll long long
#define ld long double
#define ii pair<int, int>
#define f first
#define s second
#define endl "\n"

const int MOD = 1e9 + 7;
const vector<ii> dir {{0, 1}, {1, 0}, {-1, 0}, {0, -1}};

string parse(string& st, string delimiter) {
    int pos = st.find(delimiter);
    if (pos == -1) {
        string temp = st;
        st = "";
        return temp;
    } else {
        string temp = st.substr(0, pos);
        st = st.substr(pos + delimiter.size());
        return temp;
    }
}

void part1(vector<string>& board, vector<ii>& lower_pts) {
    cout << "Part 1: " << endl;

    int ans = 0;
    int n = board.size(), m = board[0].size();

    for (int i = 0; i < n; i++) {
        for (int j = 0; j < m; j++) {
            bool lower = true;

            // Check if this pos is a lower point
            for (auto& [x,y]: dir) {
                if (i + x >= 0 && i + x < n && j + y >= 0 && j + y < m) {
                    if (board[i+x][j+y] <= board[i][j]) {
                        lower = false;
                        break;
                    }
                }
            }

            if (lower) {
                ans += ((board[i][j] - '0') + 1);
                lower_pts.push_back({i, j});
            }
        }
    }

    cout << ans << endl;
}

void part2(vector<string>& board, vector<ii> lower_pts) {
    cout << "Part 2: " << endl;

    int n = board.size();
    int m = board[0].size();
    vector<int> ans;

    // For each lower point, perform a bfs search to find adjacent value that is higher
    for (auto& [i, j]: lower_pts) {
        queue<ii> bfs;
        vector<vector<int>> visit(n, vector<int> (m));
        bfs.push({i, j});
        int size = 1;

        while (!bfs.empty()) {
            auto& [i, j] = bfs.front();
            bfs.pop();

            for (auto& [x,y]: dir) {
                if (i + x >= 0 && i + x < n && j + y >= 0 && j + y < m && !visit[i+x][j+y]) {
                    if (board[i+x][j+y] > board[i][j] && board[i+x][j+y] != '9') {
                        visit[i+x][j+y] = 1;
                        bfs.push({i+x, j+y});
                        size++;
                    }
                }
            }
        }

        ans.push_back(size);
    }

    // Find largest 3 size and mult together
    int mult = 1;
    sort(ans.begin(), ans.end());
    for (int i = 0; i < 3; i++) {
        cout << ans[ans.size() - (i+1)] << " ";
        mult *= ans[ans.size() - (i + 1)];
    }
    cout << endl;

    cout << mult << endl;
}

int main() {
    ios_base::sync_with_stdio(false);
    cin.tie(NULL);
    srand(chrono::steady_clock::now().time_since_epoch().count());

    int t = 1;

    // Read input
    string st;
    vector<string> board;
    while (getline(cin, st)) {
        board.push_back(st);
    }

    // Start Solving
    vector<ii> lower_pts;
    while (t--) {
        part1(board, lower_pts);
        cout << endl;
        part2(board, lower_pts);
    }

    cerr << "time taken : " << (float)clock() / CLOCKS_PER_SEC << " secs" << endl; 
    return 0;
}
