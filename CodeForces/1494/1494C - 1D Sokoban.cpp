/*
 * generated by github.com/calgagi/cp_gen
 * author: weiyutang
 * file: C.cpp
 * time: Fri Feb 19 14:35:40 2021
 */

#include <bits/stdc++.h>
using namespace std;
const string CP_GEN_FILE = "C";

namespace cp {

}

/* ===== BEGIN USER CODE ===== */

#define ll long long
#define ld long double
#define ii pair<int, int>
#define f first
#define s second
#define endl "\n"

int count_box(vector<int>& boxes, vector<int>& sp, int n, int m) {
    // Create a vector where v[i] is the number of boxes
    // on special position after box i
    vector<int> v(n + 1, 0);
    set<int> seen(sp.begin(), sp.end());
    for (int i = n - 1; i >= 0; i--) {
        if (seen.find(boxes[i]) != seen.end()) {
            v[i] = 1;
        } else {
            v[i] = 0;
        }

        v[i] += (i != n - 1) ? v[i + 1] : 0;
    }

    int ans = 0;

    // k is the pointer to a box, which is also the stack size
    // l and r are pointers to a special position
    for (int k = 0, l = 0, r = 0; l < m; l++) {
        // Assume the first box is at sp[r]
        // Count the size of the stack (including those after sp[r])
        while (k < n && boxes[k] <= sp[l] + k) {
            k++;
        }

        // Count how many of the boxes in the stack
        // is on a special position
        while (r < m && sp[r] - sp[l] < k) {
            // Increment count if special position is between first and last box in the stack
            r++;
        }
        
        // Add the number of boxes that are not on the stack but are on a special position
        ans = max(ans, r - l + v[k]);
    }

    return ans;
}

void solve() {
    int n, m;
    cin >> n >> m;
    vector<int> boxes_pos, boxes_neg;
    vector<int> sp_pos, sp_neg;
    for (int i = 0; i < n; i++) {
        int x; cin >> x;
        if (x > 0) boxes_pos.push_back(x);
        else if (x < 0) boxes_neg.push_back(abs(x));
    }

    for (int i = 0; i < m; i++) {
        int x; cin >> x;
        if (x > 0) sp_pos.push_back(x);
        else if (x < 0) sp_neg.push_back(abs(x));
    }

    reverse(boxes_neg.begin(), boxes_neg.end());
    reverse(sp_neg.begin(), sp_neg.end());

    int val1 = 0, val2 = 0;
    if (boxes_pos.size() > 0 && sp_pos.size() > 0) {
        val1 += count_box(boxes_pos, sp_pos, boxes_pos.size(), sp_pos.size());
    }
    if (boxes_neg.size() > 0 && sp_neg.size() > 0) {
        val2 += count_box(boxes_neg, sp_neg, boxes_neg.size(), sp_neg.size());
    }
    cout << val1 + val2 << endl;
}

int main() {
    ios_base::sync_with_stdio(false);
    cin.tie(NULL);
    srand(chrono::steady_clock::now().time_since_epoch().count());

    int t = 1;
    cin >> t;
    
    while (t--) {
        solve();
    }

    cerr << "time taken : " << (float)clock() / CLOCKS_PER_SEC << " secs" << endl; 
    return 0;
}
